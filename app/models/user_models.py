# Copyright 2014 SolidBuilds.com. All rights reserved
#
# Authors: Ling Thio <ling.thio@gmail.com>

from flask import current_app
from flask_user import UserMixin
from sqlalchemy import event
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField, validators
from app import db
from . import data_pool_models


# Define the User data model. Make sure to add the flask_user.UserMixin !!
class User(db.Model, UserMixin):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)

    # User authentication information (required for Flask-User)
    email = db.Column(db.Unicode(255), nullable=False, server_default=u'', unique=True)
    
    # password is automatically hashed in hash_user_password via an event
    password = db.Column('password', db.String(255), nullable=False, server_default='')

    active = db.Column(db.Boolean(), nullable=False, server_default='0')

    # User information
    active = db.Column('is_active', db.Boolean(), nullable=False, server_default='0')
    first_name = db.Column(db.Unicode(50), nullable=False, server_default=u'')
    last_name = db.Column(db.Unicode(50), nullable=False, server_default=u'')

    # Relationships
    roles                   = db.relationship('Role', secondary='users_roles',
                                              backref=db.backref('users', lazy='dynamic'))
    segmentations_assigned  = db.relationship('data_pool_models.ManualSegmentation',
                                              foreign_keys='data_pool_models.ManualSegmentation.assignee_id',
                                              back_populates='assignee')
    segmentations_validated = db.relationship('data_pool_models.ManualSegmentation',
                                              foreign_keys='data_pool_models.ManualSegmentation.validated_by_id',
                                              back_populates='validated_by')

    def as_dict(self):
        result = {c.name: getattr(self, c.name) for c in User.__table__.columns if c.name != 'password'}
        return result

    def __repr__(self):
        return f'{self.first_name} {self.last_name} ({self.email})'
    
    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return self.id == other.id


# automatically hash user password
@event.listens_for(User.password, 'set', retval=True)
def hash_user_password(target, value, oldvalue, initiator):
    if value != oldvalue:
        return current_app.user_manager.password_manager.hash_password(value)
    return value


# Define the Role data model
class Role(db.Model):
    __tablename__ = 'roles'
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(50), nullable=False, server_default=u'', unique=True)  # for @roles_accepted()
    label = db.Column(db.Unicode(255), server_default=u'')  # for display purposes

    def __repr__(self):
        return f'{self.name}'


# Define the UserRoles association model
class UsersRoles(db.Model):
    __tablename__ = 'users_roles'
    id = db.Column(db.Integer(), primary_key=True)
    user_id = db.Column(db.Integer(), db.ForeignKey('users.id', ondelete='CASCADE'))
    role_id = db.Column(db.Integer(), db.ForeignKey('roles.id', ondelete='CASCADE'))


# Define the User profile form
class UserProfileForm(FlaskForm):
    first_name = StringField('First name', validators=[
        validators.DataRequired('First name is required')])
    last_name = StringField('Last name', validators=[
        validators.DataRequired('Last name is required')])
    submit = SubmitField('Save')
